import { connect, disconnect, fetchBalance, fetchEnsAvatar, fetchEnsName, getAccount, getNetwork, switchNetwork, watchAccount, watchNetwork } from '@wagmi/core';
import { mainnet } from '@wagmi/core/chains';
import { Web3ModalScaffold } from '@web3modal/scaffold';
import { ADD_CHAIN_METHOD, NAMESPACE, VERSION, WALLET_CHOICE_KEY, WALLET_CONNECT_CONNECTOR_ID } from './utils/constants.js';
import { caipNetworkIdToNumber, getCaipDefaultChain, getCaipTokens } from './utils/helpers.js';
import { ConnectorExplorerIds, ConnectorImageIds, ConnectorNamesMap, ConnectorTypesMap, NetworkImageIds } from './utils/presets.js';
export class Web3Modal extends Web3ModalScaffold {
    constructor(options) {
        const { wagmiConfig, chains, defaultChain, tokens, chainImages, _sdkVersion, ...w3mOptions } = options;
        if (!wagmiConfig) {
            throw new Error('web3modal:constructor - wagmiConfig is undefined');
        }
        if (!w3mOptions.projectId) {
            throw new Error('web3modal:constructor - projectId is undefined');
        }
        if (!wagmiConfig.connectors.find(c => c.id === WALLET_CONNECT_CONNECTOR_ID)) {
            throw new Error('web3modal:constructor - WalletConnectConnector is required');
        }
        const networkControllerClient = {
            switchCaipNetwork: async (caipNetwork) => {
                const chainId = caipNetworkIdToNumber(caipNetwork?.id);
                if (chainId) {
                    await switchNetwork({ chainId });
                }
            },
            async getApprovedCaipNetworksData() {
                const walletChoice = localStorage.getItem(WALLET_CHOICE_KEY);
                if (walletChoice?.includes(WALLET_CONNECT_CONNECTOR_ID)) {
                    const connector = wagmiConfig.connectors.find(c => c.id === WALLET_CONNECT_CONNECTOR_ID);
                    if (!connector) {
                        throw new Error('networkControllerClient:getApprovedCaipNetworks - connector is undefined');
                    }
                    const provider = await connector.getProvider();
                    const ns = provider.signer?.session?.namespaces;
                    const nsMethods = ns?.[NAMESPACE]?.methods;
                    const nsChains = ns?.[NAMESPACE]?.chains;
                    return {
                        supportsAllNetworks: nsMethods?.includes(ADD_CHAIN_METHOD),
                        approvedCaipNetworkIds: nsChains
                    };
                }
                return { approvedCaipNetworkIds: undefined, supportsAllNetworks: true };
            }
        };
        const connectionControllerClient = {
            connectWalletConnect: async (onUri) => {
                const connector = wagmiConfig.connectors.find(c => c.id === WALLET_CONNECT_CONNECTOR_ID);
                if (!connector) {
                    throw new Error('connectionControllerClient:getWalletConnectUri - connector is undefined');
                }
                connector.on('message', event => {
                    if (event.type === 'display_uri') {
                        onUri(event.data);
                        connector.removeAllListeners();
                    }
                });
                const chainId = caipNetworkIdToNumber(this.getCaipNetwork()?.id);
                await connect({ connector, chainId });
            },
            connectExternal: async (id) => {
                const connector = wagmiConfig.connectors.find(c => c.id === id);
                if (!connector) {
                    throw new Error('connectionControllerClient:connectExternal - connector is undefined');
                }
                const chainId = caipNetworkIdToNumber(this.getCaipNetwork()?.id);
                await connect({ connector, chainId });
            },
            checkInjectedInstalled(ids) {
                if (!window?.ethereum) {
                    return false;
                }
                if (!ids) {
                    return Boolean(window.ethereum);
                }
                return ids.some(id => Boolean(window.ethereum?.[String(id)]));
            },
            disconnect
        };
        super({
            networkControllerClient,
            connectionControllerClient,
            defaultChain: getCaipDefaultChain(defaultChain),
            tokens: getCaipTokens(tokens),
            _sdkVersion: _sdkVersion ?? `html-wagmi-${VERSION}`,
            ...w3mOptions
        });
        this.hasSyncedConnectedAccount = false;
        this.options = undefined;
        this.options = options;
        this.syncRequestedNetworks(chains, chainImages);
        this.syncConnectors(wagmiConfig.connectors);
        watchAccount(() => this.syncAccount());
        watchNetwork(() => this.syncNetwork(chainImages));
    }
    getState() {
        const state = super.getState();
        return {
            ...state,
            selectedNetworkId: caipNetworkIdToNumber(state.selectedNetworkId)
        };
    }
    subscribeState(callback) {
        return super.subscribeState(state => callback({
            ...state,
            selectedNetworkId: caipNetworkIdToNumber(state.selectedNetworkId)
        }));
    }
    syncRequestedNetworks(chains, chainImages) {
        const requestedCaipNetworks = chains?.map(chain => ({
            id: `${NAMESPACE}:${chain.id}`,
            name: chain.name,
            imageId: NetworkImageIds[chain.id],
            imageUrl: chainImages?.[chain.id]
        }));
        this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
    }
    async syncAccount() {
        const { address, isConnected } = getAccount();
        const { chain } = getNetwork();
        this.resetAccount();
        if (isConnected && address && chain) {
            const caipAddress = `${NAMESPACE}:${chain.id}:${address}`;
            this.setIsConnected(isConnected);
            this.setCaipAddress(caipAddress);
            await Promise.all([
                this.syncProfile(address),
                this.syncBalance(address, chain),
                this.getApprovedCaipNetworksData()
            ]);
            this.hasSyncedConnectedAccount = true;
        }
        else if (!isConnected && this.hasSyncedConnectedAccount) {
            this.resetWcConnection();
            this.resetNetwork();
        }
    }
    async syncNetwork(chainImages) {
        const { address, isConnected } = getAccount();
        const { chain } = getNetwork();
        if (chain) {
            const chainId = String(chain.id);
            const caipChainId = `${NAMESPACE}:${chainId}`;
            this.setCaipNetwork({
                id: caipChainId,
                name: chain.name,
                imageId: NetworkImageIds[chain.id],
                imageUrl: chainImages?.[chain.id]
            });
            if (isConnected && address) {
                const caipAddress = `${NAMESPACE}:${chain.id}:${address}`;
                this.setCaipAddress(caipAddress);
                if (chain.blockExplorers?.default?.url) {
                    const url = `${chain.blockExplorers.default.url}/address/${address}`;
                    this.setAddressExplorerUrl(url);
                }
                if (this.hasSyncedConnectedAccount) {
                    await this.syncBalance(address, chain);
                }
            }
        }
    }
    async syncProfile(address) {
        try {
            const { name, avatar } = await this.fetchIdentity({
                caipChainId: `${NAMESPACE}:${mainnet.id}`,
                address
            });
            this.setProfileName(name);
            this.setProfileImage(avatar);
        }
        catch {
            const profileName = await fetchEnsName({ address, chainId: mainnet.id });
            if (profileName) {
                this.setProfileName(profileName);
                const profileImage = await fetchEnsAvatar({ name: profileName, chainId: mainnet.id });
                if (profileImage) {
                    this.setProfileImage(profileImage);
                }
            }
        }
    }
    async syncBalance(address, chain) {
        const balance = await fetchBalance({
            address,
            chainId: chain.id,
            token: this.options?.tokens?.[chain.id]?.address
        });
        this.setBalance(balance.formatted, balance.symbol);
    }
    syncConnectors(connectors) {
        const w3mConnectors = connectors.map(({ id, name }) => ({
            id,
            explorerId: ConnectorExplorerIds[id],
            imageId: ConnectorImageIds[id],
            name: ConnectorNamesMap[id] ?? name,
            type: ConnectorTypesMap[id] ?? 'EXTERNAL'
        }));
        this.setConnectors(w3mConnectors ?? []);
    }
}
//# sourceMappingURL=client.js.map